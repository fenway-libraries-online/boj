#!/usr/bin/perl

use strict;
use warnings;

use POSIX qw(strftime);
use IO::Scalar;
use File::Basename qw(basename);
use String::Expando;
use String::ShellQuote;
use Getopt::Long
    qw(GetOptionsFromArray :config posix_default gnu_compat require_order bundling no_ignore_case);

=for comment
Do you see _changecom(...)_ in the line below?
<changecom(`###',`\n')>
If so, you're looking at the file from which __PROG__ is built.
Otherwise, you're looking at a built copy of __PROG__.
=cut

sub result($) { $_[0] => $_[0] }

use constant result 'OK';
use constant result 'FAIL';
use constant result 'SKIP';

sub fatal;
sub usage;
sub now;

my $root     = "/var/local/__PROG__";
my $logname  = "__PROG__.log";
my $log      = "/var/log/$logname";
my @sendmail = qw(__SENDMAIL__);

my (@cmd, %opt, %cfg);
my $fhcmd;
my $projdir;
my ($err, $result, $begin, $end);
foreach (keys %ENV) {
    if (/^__PROG__()_OPT_(\S+)/) {
        $opt{lc $1} = 1;
    }
    elsif (/^__PROG__()_CFG_(\S+)/) {
        $cfg{lc $1} = $ENV{$_};
    }
}

start();
run();
finish();

# --- Functions

sub start {
    $begin = now();
    usage if !@ARGV;
    if ($ARGV[0] =~ s/^@// || -d $ARGV[0]) {
        config_project(@ARGV);
    }
    else {
        config_command(@ARGV);
    }
    $SIG{'TERM'} = $SIG{'QUIT'} = $SIG{'INT'} = \&finish;
    $SIG{'USR1'} = sub { $result = OK; goto &finish };
}

sub run {
    $err = 0;
    if ($opt{'skip'}) {
        $result = SKIP;
        return;
    }
    binmode STDOUT;
    if ($opt{'dryrun'}) {
        print STDERR "__PROG__: dry run: @cmd\n";
        exit;
    }
    # system qw(rm -f), glob('tmp/boj.*');
    my %meta;
    eval {
        #open my $fhout, '>', $cfg{'out'}
        #    or die "open $cfg{'out'}: $!";
        #open my $fhcmd, '-|', @cmd
        #    or die "exec @cmd: $!";
        my $cmd = shell_quote(@cmd) . " 2>&1 |";
        open my $fhcmd, $cmd
            or die "exec $cmd: $!";
        open my $fhout, '>', $cfg{'out'}
            or die "open $cfg{'out'}: $!";
        while (<$fhcmd>) {
            if (/^\@\$\#\!\?__PROG__:([^\s=]+)=(.*)$/) {
                $meta{$1} = $2;
            }
            else {
                print $fhout $_;
            }
        }
        close $fhcmd;
        $err = $? >> 8;
        close $fhout
            or die "close $cfg{'out'}: $!";
    };
    $err = $meta{'err'} if exists $meta{'err'};
    $result = $meta{'result'} if exists $meta{'result'};
    if (!defined $result) {
        $result = $err ? FAIL : OK;
    }
}

sub finish {
    %SIG = ();
    $end = now;
    $result = FAIL if !defined $result;
    if (!$opt{'skip'} && !$opt{'dryrun'}) {
        my $notify;
        if ($err) {
            $result = FAIL;
            $notify = 1;
        }
        elsif ($opt{'alwaysmail'}) {
            $notify = 1;
        }
        elsif (!$opt{'nomail'} && -s $cfg{'out'}) {
            $notify = 1;
        }
        send_notification() if $notify;
        unlink $cfg{'out'} if !$opt{'keepout'};
        if (!$opt{'nolog'}) {
            open my $fhlog, '>>', $cfg{'log'}
                or fatal "Can't open log file $cfg{'log'}: $!";
            printf $fhlog "%-4.4s %s %s %s\n", $result, $begin, $end, join(' ', @cmd);
        }
    }
}

sub now { strftime('%Y%m%dT%H%M%S', localtime) }

sub send_notification {
    my ($fhout, $fhmsg, $fhsendmail);
    open $fhout, '<', $cfg{'out'} or fatal "Can't read out";
    open $fhmsg, '>', $cfg{'msg'} or fatal "Can't save msg"
        if $opt{'keepout'};
    open $fhsendmail, '|-', @sendmail
        or fatal "Can't send message: $!";
    my @templates = ( "mail.$err", "mail.$result", 'mail' );
    my $fhtemplate;
    foreach (@templates) {
        if (-e $_) {
            open $fhtemplate, '<', $_ or fatal;
            last;
        }
    }
    if (!defined $fhtemplate) {
        open $fhtemplate, '<', \<<'EOS' or fatal;
From: $u@$H
To: $u@$H
Subject: $h: [$r] $J

EOS
    }
    my $expando = String::Expando->new(
        'expando' => '\$(.)',
        'literal' => '([^$]+)'
    );
    my $host = $ENV{'HOST'} || qx/hostname/; chomp $host;
    my $HOST = $host;
    $HOST =~ s/\..+//;
    my ($login) = getpwuid($>);
    my %stash = (
        '?' => $err,
        'r' => $result,
        'R' => int rand 2**15,
        'j' => basename($projdir || '.'),
        'J' => $cfg{'description'} || $projdir || '.',
        'u' => $login,
        'h' => $host,
        'H' => $HOST,
        'b' => $begin,
        'e' => $end,
        'c' => join(' ', map { quote($_) } @cmd),
    );
    my $eoh;
    while (<$fhtemplate>) {
        $eoh = 1 if /^$/;
        my $line = $expando->expand($_, \%stash);
        print $fhsendmail $line;
        print $fhmsg $line if defined $fhmsg;
    }
    if (!$eoh) {
        print $fhsendmail "\n";
        print $fhmsg "\n" if defined $fhmsg;
    }
    while (<$fhout>) {
        print $fhsendmail $_;
        print $fhmsg $_ if defined $fhmsg;
    }
}

sub find_project {
    my ($proj) = @_;
    return $proj if $proj =~ m{^/\S+$};
    my $path = $ENV{'__PROG__()_PATH'};
    ($path) = glob('~/jobs') if !defined $path;
    fatal "Can't find project $proj -- __PROG__()_PATH not set" if !defined $path;
    my @found;
    foreach (split /:+/, $path) {
        my $dir = "$_/$proj";
        next if ! -d $dir || ! -x _ || ! -r _;
        push @found, $dir;
    }
    fatal "Can't find project $proj in __PROG__()_PATH" if !@found;
    fatal "Multiple projects '$proj' in __PROG__()_PATH:", @found
        if @found > 1;
    return $found[0];
}

sub config_project {
    # usage: __PROG__ @PROJECT
    usage if @_ > 1;
    my ($proj) = @_;
    $projdir = find_project($proj);
    chdir $projdir or fatal "Can't chdir $projdir: $!";
    my $script = "$projdir/run";
    -f $script && -x _
        or fatal "No run script in $projdir";
    $cfg{'log'} = "$projdir/$logname";
    $cfg{'out'} = "$projdir/out";
    $cfg{'msg'} = "$projdir/msg";
    foreach my $optfile (qw(keepout nomail alwaysmail)) {
        $opt{$optfile} = 1 if -e $optfile;
    }
    @cmd = ( $script );
}

sub read_file_first_line {
    my ($f) = @_;
    open my $fh, '<', $f or fatal "Can't read file $f: $!";
    local $/ = "\n";
    my $str = <$fh>;
    chomp $str;
    return $str;
}

sub config_command {
    $cfg{'log'} = -w $log ? $log : (glob("~/.__PROG__()log"))[0] || fatal 'No writable log';
    $cfg{'out'} = "/tmp/__PROG__.$$.out";
    $cfg{'msg'} = "/tmp/__PROG__.$$.msg";
    $opt{'keepout'}    = 0;
    $opt{'nomail'}     = 0;
    $opt{'alwaysmail'} = 0;
    GetOptionsFromArray(
        \@_,
        'k' => \$opt{'keepout'},
        'r' => sub { delete $opt{'keepout'} },
        'q' => \$opt{'nolog'},
        'n' => \$opt{'nomail'},
        'm' => \$opt{'alwaysmail'},
        'O=s' => sub { $cfg{'out'} = $_[1]; $opt{'keepout'} = 1 },
        'L=s' => \$cfg{'log'},
        'M=s' => \$cfg{'msg'},
    ) or usage;
    @cmd = @_;
}

sub quote {
    local $_ = shift;
    return qq{"$_"} if s/(["\$\\])/\\$1/g;
    return qq{'$_'} if !/['\$\\]/;
    return $_;
}

sub usage {
    print STDERR <<"EOS";
usage: __PROG__ @PROJDIR
       __PROG__ 
EOS
    exit 1;
}

sub fatal {
    print STDERR $_, "\n" for @_;
    exit 2;
}

=pod

=head1 NAME

__PROG__ - run a command and mail unexpected output to the user

=head1 SYNOPSIS

__PROG__ [I<OPTION>...] I<COMMAND> [I<ARG]...]

__PROG__ @I<PROJDIR>

=head1 DESCRIPTION

B<__PROG__> runs I<COMMAND> and sends a message to the user containing its output
(if any) and a meaningful subject line.  No message is sent if I<COMMAND> exits
normally (i.e., with status 0).

B<__PROG__> is intended as a cron job wrapper but may be useful in any context in
which additional control over the reporting of command results is desired.

When invoked as B<__PROG__ @>I<PROJDIR> the executable file B<run> within I<PROJDIR>
is executed and run-time parameters are set via files within I<PROJDIR> as
described below.  It is an error to include any command-line options or other
arguments when invoking B<__PROG__> in this way.

=head1 OPTIONS

All options may be set in two ways: either by specifying the option in the
command line or by including an appropriately named file in an B<opt> or B<cfg>
directory within I<PROJDIR>.

=over 4

=item B<-n>, B<nomail>

Don't send mail unless the command exited with non-zero status, regardless of
whether it produced any output.

=item B<-m>, B<alwaysmail>

Always send mail, regardless of whether the command exited with non-zero status
or produced any output.

=item B<-k>, B<keepout>

Keep the temporary output file.

=item B<-r>

Do not keep the temporary output file.  This is the default.

=item B<-O> I<FILE>, B<out>

Write command output to I<FILE> (or the file named by the contents of
B<out>).

=item B<-L> I<FILE>, B<log>

Log the result in I<FILE> (or the file named by the contents of B<log>)
rather than the usual log file (/var/log/__PROG__.log if writeable, otherwise
~/.__PROG__()log).

=item B<-M> I<FILE>, B<msg>

Write the resulting message to I<FILE> (or the file named by the contents of
B<msg>).

=item B<-q>, B<nolog>

Do not log anything.  This overrides B<-L> and B<log>.

=back

=head1 ENVIRONMENT

Environment variables whose names take the form B<__PROG__()_OPT_>I<OPTION> will set
the lower-case form of I<OPTION>.  For example, if B<__PROG__()_OPT_NOMAIL> is set
then the B<nomail> option will be set.

Environment variables whose names take the form B<__PROG__()_CFG_>I<KEY>=I<VALUE> will
set the corresponding (lower-cased) configuration variable.  For example,
setting B<__PROG__()_CFG_LOG> to C<foo> has the same effect as specifying option
B<-l foo> on the command line.

=head1 DIAGNOSTICS

If I<COMMAND> (or I<PROJDIR>/run) exits with status 0, the result is logged as
C<OK> and B<__PROG__> exits with status 0.

If the command produces any output, B<__PROG__> checks the first line; if it has the
following form, with I<RESULT> matching the regular expression /^[A-Z]+$/, then
I<RESULT> will be used as the job result regardless of the command's exit
status:

@$#!?__PROG__():I<RESULT>[ I<STATUS>]

The optional I<STATUS> may be used to set the exit status of B<__PROG__>; it does
not affect the logged result.

If B<__PROG__> receives a B<USR1> signal, it concludes that the job was meant to be
cancelled: it logs a successful result and returns exit status 0.

=cut
